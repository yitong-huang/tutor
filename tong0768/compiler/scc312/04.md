### 翻译与详细解释

---

#### **第1页**
**SCC.312**  
**语言与编译**  
（第12周）  
Paul Rayson  
p.rayson@lancaster.ac.uk

---

#### **第2页**
**上周内容（第11周）**
- 形式语言定义的基本元素与方法
- 语言基本元素的定义：字符串、句子、字母表、操作
- 定义语言的不同方式：集合定义、判定程序、文法
- 推导与解析
- 短语结构文法简介

**解释**：  
第11周课程介绍了形式语言的基础概念，包括如何通过集合、判定程序或文法来定义语言。短语结构文法（Phrase Structure Grammars）是生成语言的核心工具，通过推导（从起始符号生成句子）和解析（从句子反推起始符号）来验证句子的合法性。

---

#### **第3页**
**本周主题**
1. **正则文法（Regular Grammars）**
    - 文法生成的语言 \( L(G) \)
2. **有限状态识别器（Finite State Recognisers, FSR）**
    - 非确定性（Nondeterministic）与确定性（Deterministic）
    - 子集构造算法（Subset Construction Algorithm）
3. **正则表达式（Regular Expressions）**
4. **等价性（Equivalence）**

**解释**：  
正则文法是生成正则语言的最简单文法类型。有限状态识别器（FSR）是识别正则语言的抽象机器，分为非确定性和确定性两种。子集构造算法用于将非确定性FSR转换为确定性FSR。正则表达式与正则文法、FSR在表达能力上是等价的。

---

#### **第4页**
**学习目标**  
学完第12周后，你应该能够：
1. 识别正则文法的规则格式
2. 根据正则文法生成对应的FSR，或反之
3. 判断句子是否符合给定正则文法
4. 使用子集构造算法将非确定性FSR转换为确定性FSR
5. 理解正则文法在字符串集合表示上的局限性
6. 识别正则表达式的格式
7. 理解正则文法、FSR和正则表达式之间的联系

**解释**：  
核心目标是掌握正则文法与有限状态识别器的双向转换，并理解其局限性（如无法表示嵌套结构或复杂计数问题）。正则表达式是描述正则语言的另一种方式。

---

#### **第5页**
**短语结构文法**
- **终结符（Terminals）**：语言的基本符号（如字母、数字）
- **非终结符（Non-terminals）**：定义句子结构的符号（如变量）
- **起始符号（Start Symbol）**：推导的起点
- **产生式规则（Production Rules）**：生成合法字符串的规则

**解释**：  
短语结构文法通过产生式规则（如 \( S \rightarrow aB \)）逐步替换非终结符，最终生成仅含终结符的字符串。例如，起始符号 \( S \) 可通过规则生成句子。

---

#### **第6页**
**文法分类**
- **正则文法（Regular, Type 3）**
- **上下文无关文法（Context-Free, Type 2）**
- **上下文有关文法（Context-Sensitive, Type 1）**
- **无限制文法（Unrestricted, Type 0）**

**解释**：  
根据产生式规则的复杂度，文法分为四类。正则文法是限制最严格的一类（仅允许形如 \( A \rightarrow aB \) 或 \( A \rightarrow a \) 的规则），用于描述简单模式（如电话号码）。

---

#### **第7-8页**
**正则文法（Type 3）**
- 所有产生式为以下两种形式之一：
    1. **非终结符 → 终结符 非终结符**（如 \( X \rightarrow yZ \)）
    2. **非终结符 → 终结符**（如 \( X \rightarrow t \)，\( t \) 可为空）
- 示例：
    - \( S \rightarrow aA \)
    - \( A \rightarrow rB \)
    - \( B \rightarrow c \mid m \)（生成字符串 `arc` 和 `arm`）

**解释**：  
正则文法的规则仅允许单个非终结符在右侧，且只能出现在最左或最右（左线性或右线性）。例如，规则 \( B \rightarrow c \mid m \) 表示“或”关系。

---

#### **第9-11页**
**判断正则文法**
- **非正则文法示例**：
  ```  
  S → aSYZ | aYZ  
  ZY → YZ  
  aY → ab  
  ```  
  原因：右侧包含多个非终结符（如 `SYZ`），违反正则文法规则。
- **正则文法示例**：
  ```  
  S → aS | aB | bC  
  B → bC  
  C → cC | c  
  ```  
  原因：所有规则符合右线性格式。

**解释**：  
正则文法的核心限制是产生式右侧最多包含一个非终结符，且必须位于最左或最右。若规则允许两个非终结符（如 `ZY`），则属于更复杂的文法类型。

---

#### **第12-13页**
**文法生成的语言 \( L(G) \)**
- \( L(G) \) 是所有能被文法 \( G \) 生成的终结符字符串的集合。
- 示例：
    - \( S \rightarrow aS \mid aB \mid bC \)  
      \( B \rightarrow bC \)  
      \( C \rightarrow cC \mid c \)  
      生成语言 \( \{ a^i b c^j \mid i \geq 0, j \geq 1 \} \)

**解释**：  
通过文法的产生式规则，可以生成特定模式的字符串集合。例如，上述文法生成以任意数量 `a` 开头，后跟一个 `b`，再跟至少一个 `c` 的字符串。

---

#### **第14-15页**
**推导与解析**
- **推导**：从起始符号逐步应用规则生成句子。
- **解析**：从句子反推至起始符号以验证合法性。
- **示例**：验证 `abbbac` 是否符合文法 \( G_1 \)：
  ```  
  S → aX | bY  
  X → bX | aZ  
  Y → aY | bZ  
  Z → c  
  ```  
  解析路径：\( S \rightarrow aX \rightarrow abX \rightarrow abbX \rightarrow abbbX \rightarrow abbbaZ \rightarrow abbbac \)（合法）。

**解释**：  
解析过程通过有限状态识别器（FSR）的状态转移实现。若存在一条从起始状态到终止状态的路径且消耗所有输入符号，则句子合法。

---

#### **第16-19页**
**有限状态识别器（FSR）**
- **状态**：非终结符表示状态（如 `S`, `X`, `Y`）。
- **转移**：终结符标记状态间的转移（如 `a`, `b`）。
- **终止状态**：用方框表示（如 `Z → c`）。

**示例**：  
文法 \( G_1 \) 对应的FSR：
- 状态：\( S, X, Y, Z \)
- 转移：
    - \( S \xrightarrow{a} X \)，\( S \xrightarrow{b} Y \)
    - \( X \xrightarrow{b} X \)，\( X \xrightarrow{a} Z \)
    - \( Z \xrightarrow{c} \text{终止} \)

**解释**：  
FSR通过状态转移图直观表示文法的解析过程。非确定性FSR允许同一输入符号从同一状态转移到多个不同状态，而确定性FSR要求唯一转移路径。

---

#### **第20-25页**
**非确定性与确定性FSR**
- **非确定性FSR**：存在状态-输入对的多条转移路径（需回溯尝试）。
- **确定性FSR**：每个状态-输入对唯一确定下一个状态。
- **子集构造算法**：将非确定性FSR的状态集合合并，生成等价的确定性FSR。

**示例**：  
非确定性FSR的状态转移表：  
| 状态 | a   | b   |  
|------|-----|-----|  
| S    | X,Y | -   |  
| X    | Z   | X   |

通过子集构造算法，合并状态 \( \{X,Y\} \)，生成确定性FSR。

**解释**：  
确定性FSR解析效率更高，无需回溯。子集构造算法的核心是将非确定性状态组合视为确定性FSR的单个状态。

---

#### **第26-30页**
**正则表达式**
- 描述正则语言的另一种形式（如 `a*bc+`）。
- 与正则文法和FSR等价。

**示例**：  
文法 \( S \rightarrow aS \mid aB \mid bC \) 对应正则表达式：  
\( a^*(aB \mid bC) \)

**解释**：  
正则表达式通过操作符（`*`、`|`、`+`）简洁描述字符串模式，常用于文本匹配和词法分析。

---

### **精选题目及详细解答**

---

#### **1. Chomsky层级分类（2023-24年 第1题a）**
**题目**：列出Chomsky层级中的所有文法类型，并描述每种类型的产生式规则形式及限制。

**解答**：
Chomsky层级将形式文法分为四类，按生成能力从强到弱排列：

1. **Type 0 - 无限制文法（Unrestricted Grammars）**
    - **产生式规则**：形式为 \( \alpha \rightarrow \beta \)，其中 \(\alpha\) 和 \(\beta\) 是任意字符串（\(\alpha\) 至少包含一个非终结符）。
    - **限制**：无任何限制。
    - **对应自动机**：图灵机（Turing Machine, TM）。

2. **Type 1 - 上下文有关文法（Context-Sensitive Grammars, CSG）**
    - **产生式规则**：形式为 \( \alpha A \beta \rightarrow \alpha \gamma \beta \)，其中 \(A\) 是非终结符，\(\alpha, \beta\) 是上下文字符串，\(\gamma\) 非空。
    - **限制**：规则左侧长度 ≤ 右侧长度。
    - **对应自动机**：线性有界自动机（Linear Bounded Automaton, LBA）。

3. **Type 2 - 上下文无关文法（Context-Free Grammars, CFG）**
    - **产生式规则**：形式为 \( A \rightarrow \gamma \)，其中 \(A\) 是非终结符，\(\gamma\) 是任意字符串。
    - **限制**：左侧必须为单个非终结符。
    - **对应自动机**：下推自动机（Pushdown Automaton, PDA）。

4. **Type 3 - 正则文法（Regular Grammars）**
    - **产生式规则**：右线性（\( A \rightarrow aB \) 或 \( A \rightarrow a \)）或左线性（\( A \rightarrow Ba \) 或 \( A \rightarrow a \)）。
    - **限制**：右侧最多一个非终结符，且必须位于最左或最右。
    - **对应自动机**：有限状态识别器（Finite State Recogniser, FSR）。

---

#### **2. 正则文法与FSR转换（2020-21年 第2题）**

### **2.a 生成与有限状态识别器（FSR）对应的文法**

根据补充的FSR结构，包含以下状态和转移规则：
- **状态与符号**：
    - `q0`（起始状态）：符号 `g`
    - `q1`：符号 `o`
    - `q2`：符号 `a`
    - `q3`（终止状态）：符号 `i`
- **转移规则**：
    - `q0` 接受 `g` 可转移到 `q0`（自环）或 `q1`
    - `q1` 接受 `o` 可转移到 `q1`（自环）或 `q2`
    - `q2` 接受 `a` 可转移到 `q2`（自环）或 `q3`
    - `q3` 接受 `i` 进入终止状态

#### **对应的正则文法规则**
1. **非终结符**：
    - `S`（对应 `q0`）
    - `A`（对应 `q1`）
    - `B`（对应 `q2`）
    - `C`（对应 `q3`）

2. **产生式规则**：
    - \( S \rightarrow gS \mid gA \)
    - \( A \rightarrow oA \mid oB \)
    - \( B \rightarrow aB \mid aC \)
    - \( C \rightarrow i \)

#### **验证示例**
- **有效句子**：`ggooaai`  
  推导路径：  
  \( S \rightarrow gS \rightarrow ggA \rightarrow ggoA \rightarrow ggooB \rightarrow ggooaB \rightarrow ggooaaC \rightarrow ggooaa i \)
- **无效句子**：`gai`（缺少 `o` 转移）

#### **说明**
- **自环转移的体现**：
    - \( S \rightarrow gS \) 允许任意数量的 `g`（如 `ggg...`）。
    - \( A \rightarrow oA \) 允许任意数量的 `o`（如 `ooo...`）。
    - \( B \rightarrow aB \) 允许任意数量的 `a`（如 `aaa...`）。
- **终止条件**：
    - 必须通过 `i` 结束于 `C`（终止状态）。

#### **扩展场景**
若FSR允许其他符号（如 `q3` 可自环输入 `i`），则需添加规则：
- \( C \rightarrow iC \)  
  此时语言可包含无限后缀 `i`，例如 `ggooaaiiii`。


### **2.b 有效与无效句子示例**
**有效句子**：
1. `goai`（推导路径：\( S \rightarrow gA \rightarrow oB \rightarrow aC \rightarrow i \)）
2. `ggooaai`（推导路径：\( S \rightarrow gS \rightarrow ggA \rightarrow ggoA \rightarrow ggooB \rightarrow ggooaB \rightarrow ggooaaC \rightarrow i \)）

**无效句子**：
1. `gai`（缺少 `o` 转移，无法从 `A` 到 `B`）
2. `goi`（缺少 `a` 转移，无法从 `B` 到 `C`）

---

### **2.c 非确定性状态**
FSR中的以下状态在特定输入下存在非确定性：
- **q0**（输入 `g`）：可转移到 `q0` 或 `q1`。
- **q1**（输入 `o`）：可转移到 `q1` 或 `q2`。
- **q2**（输入 `a`）：可转移到 `q2` 或 `q3`。

---

### **2.d 有效句子的集合定义**
FSR接受的语言是所有以任意数量的 `g` 开头，后跟任意数量的 `o`，再跟任意数量的 `a`，并以单个 `i` 结尾的字符串：  
\[
L = \{ g^m o^n a^p i \mid m \geq 0, n \geq 0, p \geq 0 \}
\]  
**说明**：
- 若要求至少一个 `g`, `o`, `a`，则 \( m, n, p \geq 1 \)。

---

### **2.e 通过子集构造算法生成确定性FSR**
**步骤**：
1. **初始状态**：\( \{q0\} \)。
2. **状态转移表**：  
   | 当前状态   | 输入 `g`       | 输入 `o`       | 输入 `a`       | 输入 `i`       |  
   |------------|----------------|----------------|----------------|----------------|  
   | {q0}       | {q0, q1}       | ∅              | ∅              | ∅              |  
   | {q0, q1}   | {q0, q1}       | {q1, q2}       | ∅              | ∅              |  
   | {q1, q2}   | ∅              | {q1, q2}       | {q2, q3}       | ∅              |  
   | {q2, q3}   | ∅              | ∅              | {q2, q3}       | {q3}（终止状态） |  
   | {q3}       | ∅              | ∅              | ∅              | ∅              |

**确定性FSR状态图**：
- **状态**：
    - `S0`（对应 `{q0}`）
    - `S1`（对应 `{q0, q1}`）
    - `S2`（对应 `{q1, q2}`）
    - `S3`（对应 `{q2, q3}`）
    - `S4`（对应 `{q3}`，终止状态）

- **转移**：
    - `S0` → `g` → `S1`
    - `S1` → `g` → `S1`，`o` → `S2`
    - `S2` → `o` → `S2`，`a` → `S3`
    - `S3` → `a` → `S3`，`i` → `S4`

**验证**：
- 有效句子 `goai` 的路径：  
  \( S0 \xrightarrow{g} S1 \xrightarrow{o} S2 \xrightarrow{a} S3 \xrightarrow{i} S4 \)。
- 无效句子 `gai` 的路径：  
  \( S0 \xrightarrow{g} S1 \)，无法处理 `a`。

