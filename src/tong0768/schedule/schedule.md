### 批处理作业系统中的调度

2023.q4 / 2022.q3.c / 2021.q3

#### 1. 先来先服务 First come first served

非抢占式，按照请求CPU的顺序使用CPU

* 优点：易于理解，便于应用
* 缺点：i/o密集型进程会浪费CPU

|p|a t|w t|t t|

#1 0ms   0ms   10ms  
#2 5ms   5ms   25ms  
#3 15ms  15ms  20ms
#4 18ms  17ms  32ms
#5 40ms  10ms  30ms

average turnaround = (10ms + 25 + 20 + 32 + 30) / 5  
average waiting times = (0ms + 5 + 15 + 17 + 10) / 5

#### 2. 最短作业优先 shortest job first

非抢占式

* 优点：平均等待时间短
* 缺点：需要预知运行时间

#### 3. 最短剩余时间优先 shortest remaining time next

最短作业优先的抢占式版本，总是选择剩余运行时间最短的进程运行。

* 优点：新的短作业获得良好的服务
* 缺点：需要预知运行时间

### 交互系统中的调度

#### 1. 轮转调度 Round robin

每个进程被分配一个时间片（quantum），允许该进程在该时间段中运行。   
如果时间片结束时进程还在运行，则将剥夺CPU并分配给下一个进程。  
如果时间片结束前阻塞或者结束，则CPU立刻进行转换。

#### 2. 优先级调度

#### 3. 多级队列

每次不是分配一个时间片，而是递增，2、4、8、16

#### 4. 最短进程有限

#### 5. 保证调度

#### 6. 彩票调度

#### 7. 公平共享调度

### 进程

一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。

#### 创建进程：
* 系统初始化
* 正在运行的进程调用了创建进程的系统调用（fork / CreateProcess）
* 用户请求一个新进程
* 一个批处理作业的初始化

#### 进程状态：
* 运行态，该时刻进程实际占用CPU
* 就绪态，可运行，但因为其他进程正在运行而暂时停止
* 阻塞态，除非某种外部事件发生，否则进程不能运行

#### 进程模型

操作系统维护一张进程表，每个进程占用一个进程表项。每个表项包含了进程状态的重要信息：
* 程序计数器
* 堆栈指针
* 内存分配状况
* 所打开文件的状态
* 等等

### 线程

相比进程，线程之间共享一个地址空间和所有可用数据，创建和销毁更快。

#### 线程模型

* 程序计数器
* 寄存器
* 堆栈